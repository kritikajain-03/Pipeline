/**
 * @description       : 
 * @author            : ChangeMeIn@UserSettingsUnder.SFDoc
 * @group             : 
 * @last modified on  : 01-08-2026
 * @last modified by  : ChangeMeIn@UserSettingsUnder.SFDoc
**/
public class LoginInsightAnalyzer implements ISecurityAnalyzer{
    public class SecurityInsightRecord {
        public String Id { get; set; }
        public String Name { get; set; }
        public Date IncidentDate { get; set; }
        public String Insight { get; set; }
        public String Risk { get; set; }
        public String InsightTitle { get; set; }
        public String Recommendation { get; set; }
    }

    public String getRuleName() {return 'Login Insight';}

    public String getCategory() {return 'LOGIN_ACTIVITY';}

    public Boolean isEnabled() {return true;}

    public String getQuery() {
        return
            'SELECT Id, Username, LastLoginDate ' +
            'FROM User ' +
            'WHERE IsActive = true ' +
            'AND LastLoginDate >= LAST_N_MONTHS:6';
    }

    public void evaluate(Boolean useAI, List<User> scope) {jkcnsdjcndijcnsjkdcn
        // Case 1: AI is OFF → Rule-based detection only
        if (!useAI) {
          createLoginInsightsWithAlgorithm(scope);
        }
        // Case 2: AI is ON → AI-based insights only
        if(useAI){
            createLoginInsightsWithAi(scope);
        }  
    }

    //chaining batch   
    public void finish(Map<String, Boolean> batchMap) {
        String nextbatch='ConnectedAppAnalyzer';
        database.executeBatch(new SecurityAnalyzerBatch(nextbatch,batchMap,3),2);
    }

    public List<SObject> getDeletedList() {
        List<SObject> existingLoginOperationsList = [SELECT Id FROM Security_Insight__c WHERE Operation__c = 'Login'];
        return existingLoginOperationsList;    
    }
    @TestVisible
    public void createLoginInsightsWithAlgorithm(List<User> scope) {
        List<Security_Insight__c> allInsightsToInsert = new List<Security_Insight__c>();

        allInsightsToInsert.addAll(detectFailedAttempts(scope));
        allInsightsToInsert.addAll(detectUnusualIPs(scope));
        allInsightsToInsert.addAll(detectImpossibleTravel(scope));

        if (!allInsightsToInsert.isEmpty()) {
            insert allInsightsToInsert;
        }
    }
    @TestVisible
    private static List<Security_Insight__c> detectUnusualIPs(List<User> scope) {
        List<Security_Insight__c> insights = new List<Security_Insight__c>();
        Set<Id> userIds = new Set<Id>();
        for (User u : scope) {userIds.add(u.Id);}
        Datetime sevenDaysAgo = System.now().addDays(-7);
        Date today = Date.today();
        List<AuthSession> authSessions = [SELECT UsersId, SourceIp FROM AuthSession WHERE UsersId IN :userIds];
        Map<Id, Set<String>> knownIpsByUser = new Map<Id, Set<String>>();
        
		Map<Id, Map<Date, Set<String>>> suspiciousByUserDate =new Map<Id, Map<Date, Set<String>>>();

          for (LoginHistory lh :[SELECT UserId, SourceIp FROM LoginHistory WHERE UserId IN :userIds
                AND LoginTime < :sevenDaysAgo AND LoginTime >= LAST_N_MONTHS:6]) 
          {
               if (!knownIpsByUser.containsKey(lh.UserId)) {
                   knownIpsByUser.put(lh.UserId, new Set<String>());
               }
               knownIpsByUser.get(lh.UserId).add(lh.SourceIp);
          }
          for (LoginHistory lh : [SELECT UserId, SourceIp, LoginTime
                    FROM LoginHistory WHERE UserId IN :userIds AND LoginTime >= :sevenDaysAgo]) 
          {
            if (!knownIpsByUser.containsKey(lh.UserId) || !knownIpsByUser.get(lh.UserId).contains(lh.SourceIp)) {
                Date loginDate = lh.LoginTime.date();
                if (!suspiciousByUserDate.containsKey(lh.UserId)) {
                    suspiciousByUserDate.put(lh.UserId,new Map<Date, Set<String>>());
                }
                Map<Date, Set<String>> dateMap = suspiciousByUserDate.get(lh.UserId);
                if (!dateMap.containsKey(loginDate)) {
                    dateMap.put(loginDate, new Set<String>());
                }
                dateMap.get(loginDate).add(lh.SourceIp);
                if (!knownIpsByUser.containsKey(lh.UserId)) {
                    knownIpsByUser.put(lh.UserId, new Set<String>()); 
            } 
            knownIpsByUser.get(lh.UserId).add(lh.SourceIp);
        }
    }
     for (AuthSession asn : authSessions) {  
        if (!knownIpsByUser.containsKey(asn.UsersId) ||
            !knownIpsByUser.get(asn.UsersId).contains(asn.SourceIp)) {
            if (!suspiciousByUserDate.containsKey(asn.UsersId)) {
                suspiciousByUserDate.put(asn.UsersId,new Map<Date, Set<String>>());
            }
            Map<Date, Set<String>> dateMap = suspiciousByUserDate.get(asn.UsersId);
            if (!dateMap.containsKey(today)) {
                dateMap.put(today, new Set<String>());
            }

            dateMap.get(today).add(asn.SourceIp);
            if (!knownIpsByUser.containsKey(asn.UsersId)) {
                knownIpsByUser.put(asn.UsersId, new Set<String>());
            }
            knownIpsByUser.get(asn.UsersId).add(asn.SourceIp);
        }
    }

    if (suspiciousByUserDate.isEmpty()) return insights;
        Map<Id, User> usersMap = new Map<Id, User>(
            [SELECT Id, Name FROM User WHERE Id IN :suspiciousByUserDate.keySet()]			
        );

        for (Id uid : suspiciousByUserDate .keySet()) {
            User u = usersMap.get(uid);
            for (Date d : suspiciousByUserDate.get(uid).keySet()) {
                insights.add(new Security_Insight__c(
                    Name               = 'Unusual IP Activity - ' + u.Name,
                    ResourceName__c    = u.Name,
                    Operation__c       = 'Login',
                    Severity__c        = 'High',
                    Incident_Date__c   = d,
                    User__c            = u.id,
                    Description__c     =
                        'Unknown IP activity detected on ' + d.format() + '. ' +
                        'IPs: ' + String.join(
                            new List<String>(suspiciousByUserDate.get(uid).get(d)), ', '
                        ) +
                        '. These IPs were not observed in the prior 6-month baseline.'
                ));
            }
        }
        return insights;
    }
    
    @testVisible
    private List<Security_Insight__c> detectImpossibleTravel(List<User> scope) {
        List<Security_Insight__c> allInsights = new List<Security_Insight__c>();
        for (User u : scope) {
            List<Security_Insight__c> insights = ImpossibleTravelService.generateSecurityInsights(u.Id);
            allInsights.addAll(insights); // collect per-user insights
        }
        return allInsights;
    }
    @testVisible
    private static List<Security_Insight__c> detectFailedAttempts(List<User> scope) {
        List<Security_Insight__c> insights = new List<Security_Insight__c>();
        Integer threshold    = 3;
        Integer windowMillis = 10 * 60 * 1000; // 10 minutes
    
        Set<Id> userIds = new Set<Id>();
        for (User u : scope) {
            userIds.add(u.Id);
        }
    
        Map<Id, User> userMap = new Map<Id, User>([SELECT Id, Name FROM User WHERE Id IN :userIds]);
    
        List<LoginHistory> logs = [
            SELECT UserId, Status, LoginTime, SourceIp
            FROM LoginHistory
            WHERE UserId IN :userIds
            AND LoginTime >= LAST_N_MONTHS:6
            ORDER BY UserId, LoginTime ASC
        ];
    
        Map<Id, Integer> streak = new Map<Id, Integer>();
        Map<Id, Datetime> windowStart = new Map<Id, Datetime>();
        Map<Id, Boolean> insightEmitted = new Map<Id, Boolean>();
    
        for (LoginHistory logH : logs) {
            if (!streak.containsKey(logH.UserId)) {
                streak.put(logH.UserId, 0);
                windowStart.put(logH.UserId, null);
                insightEmitted.put(logH.UserId, false);
            }
            Boolean isFailure = logH.Status == 'Invalid Password' ||logH.Status.startsWith('Failed');
            if (isFailure) {
                Datetime start = windowStart.get(logH.UserId);
                if (start == null || logH.LoginTime.getTime() - start.getTime() > windowMillis) {
                    streak.put(logH.UserId, 1);
                    windowStart.put(logH.UserId, logH.LoginTime);
                    insightEmitted.put(logH.UserId, false);
                } else {
                    streak.put(logH.UserId, streak.get(logH.UserId) + 1);
                }
                
                if (streak.get(logH.UserId) >= threshold && !insightEmitted.get(logH.UserId)) {
                    User u = userMap.get(logH.UserId);
                    Datetime startDT = windowStart.get(logH.UserId);
                    Datetime endDT   = logH.LoginTime;
                    Long durationMs = endDT.getTime() - startDT.getTime();
                    Long mins = durationMs / (60 * 1000);
                    Long secs = (durationMs - (mins * 60 * 1000)) / 1000;
                    date incident= endDT.date();
                    string incident_date= DateTime.newInstance(incident.year(), incident.month(), incident.day()).format('yyyy-MM-dd');
                    
                    insights.add(new Security_Insight__c(
                        Name = 'Suspicious Failed Login Sequence for ' + u.Name,
                        ResourceName__c  = u.Name,	
                        Operation__c     = 'Login',
                        User__c          = u.Id,
                        Severity__c      = 'Medium',
                        Incident_Date__c = endDT.date(),
                        Description__c   =
                            'Multiple (' + streak.get(logH.UserId) +
                            ') consecutive failed login attempts were detected for user ' +
                            u.Name + ' on ' + incident_date +
                            ' within a ' + mins + 'm ' + secs + 's window. ' +
                            'This indicate a brute-force or password guessing attack.'
                        ));
                    insightEmitted.put(logH.UserId, true);
                }
            } else {
                streak.put(logH.UserId, 0);
                windowStart.put(logH.UserId, null);
                insightEmitted.put(logH.UserId, false);
            }
        }
        return insights;
    }

    private void createLoginInsightsWithAI(List<User> activeUserList) {
        // user IDs
        List<String> userIds = new List<String>();
        for (User u : activeUserList) {
            userIds.add(u.Id);
        }
		String aiRawResponse;
        if (Test.isRunningTest()) {
            aiRawResponse =
                '[{"Id":"'+activeUserList[0].Id+'",' +
                '"Name":"Test User",' +
                '"IncidentDate":"2026-01-01",' +
                '"Insight":"AI detected risk",' +
                '"Risk":"High",' +
                '"InsightTitle":"AI Login Risk",' +
                '"Recommendation":"Reset password"}]';
         }else{
                String userIdCsv = String.join(userIds, ',');
                String promptHandler = 'LoginPromptHandler';
                aiRawResponse = GenAIUtil.invokeAIPromptTemplate(userIdCsv, promptHandler);
         }
        
        // sanitize raw AI response
        aiRawResponse = cleanAIOutput(aiRawResponse);
        if (aiRawResponse =='[]') {
            System.debug('AI response is empty or invalid JSON. Skipping DML insight creation.');
            return;
        }
        // Extract JSON array (starts with [ and ends with ])
        Pattern p = Pattern.compile('(?s)\\[.*\\]'); // (?s) enables DOTALL
        Matcher m = p.matcher(aiRawResponse);

        String jsonString;
        if (m.find()) {jsonString = m.group(0);} 
        else {jsonString = '[]';}
       List<SecurityInsightRecord> wrapperResponse = (List<SecurityInsightRecord>) JSON.deserialize(jsonString, List<SecurityInsightRecord>.class);
        if (wrapperResponse == null || wrapperResponse.isEmpty()) {
            return;
        }
        // new Security_Insight__c records
        List<Security_Insight__c> latestSecurityInsightList = new List<Security_Insight__c>();
        for (SecurityInsightRecord rec : wrapperResponse) {
                if (rec == null ||
                String.isBlank(rec.Id) ||
                String.isBlank(rec.Name) ||
                String.isBlank(rec.InsightTitle) ||
                String.isBlank(rec.Insight) ||
                rec.IncidentDate == null ||
                String.isBlank(rec.Risk) ||
                String.isBlank(rec.Recommendation)) {
                continue;
            }
            latestSecurityInsightList.add(new Security_Insight__c(
                 User__c          = rec.Id,
                 ResourceName__c  = rec.Name,
                 Incident_Date__c = rec.IncidentDate,
                 Description__c   = EncodingUtil.urlDecode(rec.Insight, 'UTF-8').replaceAll('&#39;|&#x27;|&apos;', '\''),
                 Severity__c      = rec.Risk,
                 Name             = rec.InsightTitle,
                 Recommendation__c= rec.Recommendation,
                 Operation__c     = 'Login'
            ));
        }

        if (!latestSecurityInsightList.isEmpty()) {
            try {
                insert latestSecurityInsightList;  
            } catch (Exception e) {
                System.debug('Error inserting Security Insights: ' + e.getMessage());
            }
        }
    }
    // --- Clean AI Output ---

   @TestVisible
    private static String cleanAIOutput(String raw) {
        if (String.isBlank(raw)) {
            System.debug('AI response is blank. Returning empty list.');
            return '[]';
        }
        // Step 1: Normalize
        String cleaned = raw.replace('\u00A0', ' ').replaceAll('(?i)json', '').replaceAll('(?i)', '').trim();
        // Step 2: Remove leading "json" text if present
        if (cleaned.toLowerCase().startsWith('json')) {
            cleaned = cleaned.substring(4).trim();
        }
        // Step 3: Check if the cleaned string is valid JSON
        if (!(cleaned.startsWith('[') || cleaned.startsWith('{'))) {
            System.debug('AI response is invalid JSON after cleaning. Skipping DML insight creation.');
            return '[]';
        }
        return cleaned;
    }
}